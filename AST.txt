Rats! Parser Generator, v. 2.1.1, (C) 2004-2011 Robert Grimm
Processing Java.rats ...
// ===========================================================================
// Generated by Rats!, version 2.1.1, (C) 2004-2011 Robert Grimm.
// ===========================================================================

/**
 * Java grammar with AST support.
 * 
 * @author Robert Grimm
 * @author Stacey Kuznetsov
 * @version $Revision: 1.13 $
 */
module xtc.lang.Java;

define<Node> CompilationUnit = 
  PackageDeclaration? ImportDeclaration* Declaration*
  ;

define<Node> PackageDeclaration = 
  null QualifiedIdentifier
  ;

define<Node> ImportDeclaration = 
  null QualifiedIdentifier DotStarTail?
  ;

expand<String> DotStarTail = 
  "*":Symbol
  ;

define<Node> Modifiers = 
  ModifierList
  ;

define<Pair<Node>> ModifierList = 
  Modifier*
  ;

define<Node> Modifier = 
  "public":Word
  / "protected":Word
  / "private":Word
  / "static":Word
  / "abstract":Word
  / "final":Word
  / "native":Word
  / "synchronized":Word
  / "transient":Word
  / "volatile":Word
  / "strictfp":Word
  ;

define<Node> FormalParameter = 
  VariableModifiers Type null Identifier Dimensions?
  ;

define<Node> VariableModifiers = 
  FinalModifier @Modifiers
  / @Modifiers
  ;

define<Node> FinalModifier = 
  "final":Word @Modifier
  ;

define<Node> FormalParameters = 
  FormalParameter FormalParameter*
  / 
  ;

define<Node> Declarator = 
  Identifier Dimensions? VariableInitializer?
  ;

define<Node> Declarators = 
  Declarator Declarator*
  ;

define<Node> ClassBody = 
  Declaration*
  ;

expand<Node> Declaration = 
  FieldDeclaration
  / MethodDeclaration
  / ConstructorDeclaration
  / ClassDeclaration
  / InterfaceDeclaration
  / BlockDeclaration
  / EmptyDeclaration
  ;

define<Node> FieldDeclaration = 
  Modifiers Type Declarators
  ;

define<Node> MethodDeclaration = 
  Modifiers null ResultType Identifier FormalParameters Dimensions? 
  ThrowsClause? ( /* Choice */ 
    Block
    / null
  )
  ;

define<Node> ConstructorDeclaration = 
  Modifiers null Identifier FormalParameters ThrowsClause? Block
  ;

define<Node> ClassDeclaration = 
  Modifiers Identifier null Extension? Implementation? ClassBody
  ;

define<Node> InterfaceDeclaration = 
  Modifiers Identifier null Extension? ClassBody
  ;

define<Node> BlockDeclaration = 
  ("static":Word)? Block
  ;

define<Node> EmptyDeclaration = /* Empty */ ;

define<Node> ThrowsClause = 
  QualifiedIdentifier QualifiedIdentifier*
  ;

define<Node> Extension = 
  Type Type*
  ;

define<Node> Implementation = 
  Type Type*
  ;

define<Node> Block = 
  DeclarationOrStatement*
  ;

expand<Node> DeclarationOrStatement = 
  InBlockDeclaration
  / Statement
  ;

expand<Node> InBlockDeclaration = 
  VariableDeclaration
  / ClassDeclaration
  / InterfaceDeclaration
  ;

define<Node> VariableDeclaration = 
  VariableModifiers Type Declarators @FieldDeclaration
  ;

expand<Node> Statement = 
  Block
  / ConditionalStatement
  / ForStatement
  / WhileStatement
  / DoWhileStatement
  / TryCatchFinallyStatement
  / SwitchStatement
  / SynchronizedStatement
  / ReturnStatement
  / ThrowStatement
  / BreakStatement
  / ContinueStatement
  / LabeledStatement
  / ExpressionStatement
  / AssertStatement
  / EmptyStatement
  ;

define<Node> ConditionalStatement = 
  ParExpression Statement ( /* Choice */ 
    Statement
    / null
  )
  ;

define<Node> ForStatement = 
  BasicForControl Statement
  ;

define<Node> BasicForControl = 
  VariableModifiers Type Declarators Expression? ExpressionList?
  / null null ExpressionList? Expression? ExpressionList?
  ;

define<Node> WhileStatement = 
  ParExpression Statement
  ;

define<Node> DoWhileStatement = 
  Statement ParExpression
  ;

expand<Node> ParExpression = 
  Expression
  ;

define<Node> TryCatchFinallyStatement = 
  null Block ( /* Choice */ 
    CatchClause* Block
    / CatchClause+ null
  )
  ;

define<Node> CatchClause = 
  FormalParameter Block
  ;

define<Node> SwitchStatement = 
  ParExpression SwitchClause*
  ;

expand<Node> SwitchClause = 
  CaseClause
  / DefaultClause
  ;

define<Node> CaseClause = 
  Expression DeclarationOrStatement*
  ;

define<Node> DefaultClause = 
  DeclarationOrStatement*
  ;

define<Node> SynchronizedStatement = 
  ParExpression Block
  ;

define<Node> ReturnStatement = 
  Expression?
  ;

define<Node> ThrowStatement = 
  Expression
  ;

define<Node> BreakStatement = 
  Identifier?
  ;

define<Node> ContinueStatement = 
  Identifier?
  ;

define<Node> LabeledStatement = 
  Identifier Statement
  ;

define<Node> ExpressionStatement = 
  Expression
  ;

define<Node> AssertStatement = 
  Expression Expression?
  ;

define<Node> EmptyStatement = /* Empty */ ;

define<Node> ExpressionList = 
  Expression Expression*
  ;

define<Node> Expression = 
  ConditionalExpression AssignmentOperator Expression
  / yyValue:ConditionalExpression
  ;

expand<String> AssignmentOperator = 
  "=":Symbol
  / "+=":Symbol
  / "-=":Symbol
  / "*=":Symbol
  / "/=":Symbol
  / "&=":Symbol
  / "|=":Symbol
  / "^=":Symbol
  / "%=":Symbol
  / "<<=":Symbol
  / ">>=":Symbol
  / ">>>=":Symbol
  ;

define<Node> ConditionalExpression = 
  LogicalOrExpression Expression ConditionalExpression
  / yyValue:LogicalOrExpression
  ;

define<Node> LogicalOrExpression = 
  LogicalOrExpression LogicalAndExpression
  / yyValue:LogicalAndExpression
  ;

define<Node> LogicalAndExpression = 
  LogicalAndExpression BitwiseOrExpression
  / yyValue:BitwiseOrExpression
  ;

define<Node> BitwiseOrExpression = 
  BitwiseOrExpression BitwiseXorExpression
  / yyValue:BitwiseXorExpression
  ;

define<Node> BitwiseXorExpression = 
  BitwiseXorExpression BitwiseAndExpression
  / yyValue:BitwiseAndExpression
  ;

define<Node> BitwiseAndExpression = 
  BitwiseAndExpression EqualityExpression
  / yyValue:EqualityExpression
  ;

define<Node> EqualityExpression = 
  EqualityExpression EqualityOperator InstanceOfExpression
  / yyValue:InstanceOfExpression
  ;

expand<String> EqualityOperator = 
  "==":Symbol
  / "!=":Symbol
  ;

define<Node> InstanceOfExpression = 
  RelationalExpression Type
  / yyValue:RelationalExpression
  ;

define<Node> RelationalExpression = 
  RelationalExpression RelationalOperator ShiftExpression
  / yyValue:ShiftExpression
  ;

expand<String> RelationalOperator = 
  "<":Symbol
  / ">":Symbol
  / "<=":Symbol
  / ">=":Symbol
  ;

define<Node> ShiftExpression = 
  ShiftExpression ShiftOperator AdditiveExpression
  / yyValue:AdditiveExpression
  ;

expand<String> ShiftOperator = 
  "<<":Symbol
  / ">>":Symbol
  / ">>>":Symbol
  ;

define<Node> AdditiveExpression = 
  AdditiveExpression AdditiveOperator MultiplicativeExpression
  / yyValue:MultiplicativeExpression
  ;

expand<String> AdditiveOperator = 
  "+":Symbol
  / "-":Symbol
  ;

define<Node> MultiplicativeExpression = 
  MultiplicativeExpression MultiplicativeOperator UnaryExpression
  / yyValue:UnaryExpression
  ;

expand<String> MultiplicativeOperator = 
  "*":Symbol
  / "/":Symbol
  / "%":Symbol
  ;

define<Node> UnaryExpression = 
  "+":Symbol UnaryExpression
  / "-":Symbol UnaryExpression
  / "++":Symbol UnaryExpression
  / "--":Symbol UnaryExpression
  / yyValue:UnaryExpressionNotPlusMinus
  ;

expand<Node> UnaryExpressionNotPlusMinus = 
  BitwiseNegationExpression
  / LogicalNegationExpression
  / BasicCastExpression
  / CastExpression
  / PostfixExpression
  ;

define<Node> BitwiseNegationExpression = 
  UnaryExpression
  ;

define<Node> LogicalNegationExpression = 
  UnaryExpression
  ;

define<Node> BasicCastExpression = 
  PrimitiveType Dimensions? UnaryExpression
  ;

define<Node> CastExpression = 
  Type UnaryExpressionNotPlusMinus
  ;

define<Node> PostfixExpression = 
  PostfixExpression ( /* Choice */ 
    null ( /* Choice */ 
      Identifier Arguments @CallExpression
      / "super":Word Arguments @CallExpression
    )
    / @SuperExpression
    / Identifier @SelectionExpression
    / Expression @SubscriptExpression
    / "++":Symbol
    / "--":Symbol
    / null TypeName Arguments ClassBody? @NewClassExpression
  )
  / yyValue:PrimaryExpression
  ;

expand<Node> PrimaryExpression = 
  Literal
  / CallExpression
  / ClassLiteralExpression
  / ThisCallExpression
  / ThisExpression
  / SuperCallExpression
  / SuperExpression
  / PrimaryIdentifier
  / NewClassExpression
  / NewArrayExpression
  / Expression
  ;

define<Node> CallExpression = 
  null null Identifier Arguments
  ;

define<Node> ClassLiteralExpression = 
  ResultType
  ;

define<Node> ThisCallExpression = 
  null null "this":Word Arguments @CallExpression
  ;

define<Node> ThisExpression = 
  QualifiedIdentifier?
  ;

define<Node> SuperCallExpression = 
  null null "super":Word Arguments @CallExpression
  ;

define<Node> SuperExpression = 
  null
  ;

define<Node> PrimaryIdentifier = 
  Identifier
  ;

define<Node> NewClassExpression = 
  null null TypeName Arguments ClassBody?
  ;

define<Node> NewArrayExpression = 
  TypeName ( /* Choice */ 
    ConcreteDimensions Dimensions? null
    / null Dimensions? ArrayInitializer
  )
  ;

define<Node> ConcreteDimensions = 
  ConcreteDimension+
  ;

expand<Node> ConcreteDimension = 
  Expression
  ;

define<Node> ArrayInitializer = 
  VariableInitializer VariableInitializer*
  / 
  ;

expand<Node> VariableInitializer = 
  ArrayInitializer
  / Expression
  ;

define<Node> Arguments = 
  Expression Expression*
  / 
  ;

expand<Node> ResultType = 
  VoidType
  / Type
  ;

define<Node> VoidType = /* Empty */ ;

define<Node> Type = 
  TypeName Dimensions?
  ;

expand<Node> TypeName = 
  PrimitiveType
  / QualifiedIdentifier
  ;

define<Node> PrimitiveType = 
  "byte":Word
  / "short":Word
  / "char":Word
  / "int":Word
  / "long":Word
  / "float":Word
  / "double":Word
  / "boolean":Word
  ;

define<Node> Dimensions = 
  ("[":Symbol)+
  ;

expand<Node> Literal = 
  FloatingPointLiteral
  / IntegerLiteral
  / CharacterLiteral
  / StringLiteral
  / BooleanLiteral
  / NullLiteral
  ;

define<Node> IntegerLiteral = 
  HexLiteral
  / OctalLiteral
  / DecimalLiteral
  ;

define<String> HexLiteral = ... ;

define<String> OctalLiteral = ... ;

define<String> DecimalLiteral = ... ;

define<Node> FloatingPointLiteral = 
  FloatingPointString
  ;

define<String> FloatingPointString = ... ;

define<Node> CharacterLiteral = 
  CharacterConstant
  ;

define<Node> StringLiteral = 
  StringConstant
  ;

define<String> CharacterConstant = ... ;

define<String> StringConstant = ... ;

define<Node> BooleanLiteral = 
  "true":Word
  / "false":Word
  ;

define<Node> NullLiteral = /* Empty */ ;

define<Node> QualifiedIdentifier = 
  Identifier Identifier*
  ;

expand<String> Identifier = 
  Word
  ;

expand<String> Word = 
  WordCharacters
  ;

define<String> WordCharacters = ... ;

expand<String> Symbol = 
  SymbolCharacters
  ;

define<String> SymbolCharacters = ... ;

// ===========================================================================

